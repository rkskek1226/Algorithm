**병합 정렬(Merge Sort)**

* 분할 정복 방식으로 쪼갤 수 없을 때까지 분할한 후 분할이 끝나면 정렬하면서 정복


* 최선과 최악 모두 O(n logN)
* 안정 정렬

<br>

<br>

**퀵 정렬(Quick Sort)**

* 분할 정복 방식으로 피벗보다 작으면 왼쪽, 크면 오른쪽으로 파티셔닝하면서 쪼갬
* 로무토 파티션 : 항상 맨 오른쪽의 피벗을 선택하는 방식
* 최선의 경우에는 O(n logN)이지만 최악의 경우 O(n^2)
* 불안정 정렬   

<br>

<br>

**이진 탐색(Binary Search)**

* O(logN)
* left와 right를 설정 후 mid를 통해 탐색 범위를 반씩 줄여나가는 방식


<br>

<br>

**그리디 알고리즘(Greedy Algorithm)**

* 각 단계에서 가장 최선의 선택을 하는 방식
* 탐욕 선택 속성(Greedy Choice Property)을 갖고 있는 최적 부분 구조(Optimal Substructure) 문제에서 잘 작동
* 탐욕 선택 속성 : 앞의 선택이 이후 선택에 영향을 주지 않는 속성
* 최적 부분 구조 :  문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 구조
* 짐을 쪼갤 수 있는 배낭 문제의 경우 그리디 알고리즘으로 해결하며 짐을 쪼갤 수 없는 배낭 문제의 경우 DP로 해결


<br>

<br>

**분할 정복(Divide and Conquer)**

* 원래 문제를 작은 문제로 분할해서 해결한 후 합쳐서 원래 문제를 해결하는 방식
* 분할 -> 정복 -> 조합
* 분할 : 문제를 동일한 유형의 여러 하위 문제로 나눔
* 정복 : 가장 작은 단위의 하위 문제를 해결해 정복
* 조합 : 하위 문제에 대한 결과를 원래 문제에 대한 결과로 조합

<br>

<br>

**다이나믹 프로그래밍(Dynamic Programming)**

* 원래 문제를 작은 문제로 나누어 해결한 결과를 저장했다가 나중에 큰 문제의 결과와 합하여 문제를 해결하는 방식
* 중복된 하위 문제들의 결과를 저장했다가 풀이해 나감(순간에 최적이라고 생각되는 것을 선택하면서 풀이하는 것은 그리디 알고리즘)
* 최적 부분 구조 문제를 풀이하는데 사용
* 상향식(Bottom-Up)과 하향식(Top-Down) 방식이 있음

<br>

**상향식(Bottom-Up)**

* 타뷸레이션(Tabulation)이라 부름

* 하위 문제부터 살펴본 다음 하위 문제의 정답을 이용해 큰 문제의 정답을 풀어감

  ```pyth
  def fib(n):
      dp[0] = 0
      dp[1] = 1
      
      for i in range(2, n + 1):
  		dp[i] = dp[i - 1] + dp[i - 2]
  	return dp[n]
  ```

<br>

**하향식(Top-Down)**

* 메모이제이션(Memoization)이라 부름
* 하위 문제에 대한 정답을 계산했는지 확인해가며 문제를 풀어감

```pyth
def fib(n):
	if n <= 1:
		return n
		
	if dp[n]:
		return dp[n]
	dp[n] = fib(n - 1) + fib(n - 2)
	return dp[n]
```

<br>

| 알고리즘       | 풀이 가능한 문제 특징            | 풀이 가능한 문제 및 알고리즘                       |
| ---------- | ----------------------- | -------------------------------------- |
| 다이나믹 프로그래밍 | 최적 부분 구조<br />중복된 하위 문제 | 0-1 배낭 문제<br />피보나치 수열<br />다익스트라 알고리즘 |
| 그리디 알고리즘   | 최적 부분 구조<br />탐욕 선택 속성  | 분할 가능 배낭 문제<br />다익스트라 알고리즘            |
| 분할 정복      | 최적 부분 구조                | 병합 정렬<br />퀵 정렬                        |

