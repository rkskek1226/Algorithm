**병합 정렬(Merge Sort)**

* 분할 정복 방식으로 쪼갤 수 없을 때까지 분할한 후 분할이 끝나면 정렬하면서 정복


* 최선과 최악 모두 O(n logN)
* 안정 정렬

<br>

<br>

**퀵 정렬(Quick Sort)**

* 분할 정복 방식으로 피벗보다 작으면 왼쪽, 크면 오른쪽으로 파티셔닝하면서 쪼갬
* 로무토 파티션 : 항상 맨 오른쪽의 피벗을 선택하는 방식
* 최선의 경우에는 O(n logN)이지만 최악의 경우 O(n^2)
* 불안정 정렬   

<br>

<br>

**이진 탐색(Binary Search)**

* O(logN)
* left와 right를 설정 후 mid를 통해 탐색 범위를 반씩 줄여나가는 방식


<br>

<br>

**그리디 알고리즘(Greedy Algorithm)**

* 각 단계에서 가장 최선의 선택을 하는 방식
* 탐욕 선택 속성(Greedy Choice Property)을 갖고 있는 최적 부분 구조(Optimal Substructure) 문제에서 잘 작동
* 탐욕 선택 속성 : 앞의 선택이 이후 선택에 영향을 주지 않는 속성
* 최적 부분 구조 :  문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 구조
* 짐을 쪼갤 수 있는 배낭 문제의 경우 그리디 알고리즘으로 해결하며 짐을 쪼갤 수 없는 배낭 문제의 경우 DP로 해결

