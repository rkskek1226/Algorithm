**배열(Array)**

* 배열의 데이터를 조회하는 경우 : O(1)
* 배열의 마지막에 삽입하거나 삭제하는 경우 : O(1)
* 배열의 마지막에 삽입하는데 가득 차 있는 경우 : 공간을 확보하고 기존의 배열을 모두 복사하고 새로운 데이터를 추가하므로 O(n)이지만 분할 상환 분석으로는 O(1)
* 배열의 중간에 삽입하거나 삭제하는 경우 : 기존 요소들을 옮기고 삽입·삭제하므로 O(n)

<br>

<br>

**연결 리스트(Linked list)**

* 노드(node)는 데이터와 링크로 구성됨.
* 연결 리스트에 데이터를 조회하는 경우 : O(n)
* 연결 리스트에 삽입하거나 삭제하는 경우 : O(1)

<br>

**런너(Runner) 기법**

* 연결 리스트를 순회할 때 2개의 포인터를 사용하는 기법.
* 첫번째 포인터를 빠른 런너(Fast Runner), 두번재 포인터를 느린 런너(Slow Runner)로 부름
* 빠른 런너는 두 칸씩 이동하고 느린 런너는 한 칸씩 이동함.
* 느린 런너는 처음부터 중간까지 이동하면서 역순으로 연결 리스트를 만들면서 감.
* 빠른 런너가 연결 리스트의 끝에 도달하면 느린 런너는 정확히 중간 지점에 도착함.
* 중간 지점에 도달한 런너가 끝으로 이동하면서 만나는 값이 역순으로 만든 연결 리스트의 값과 일치한다면 펠린드롬.

<br>

<br>

**스택(Stack)**

* First In Last Out, Last In First Out
* 파이썬에서는 리스트를 이용해 스택처럼 사용할 수 있음.
* 리스트의 append()를 스택의 push()로, 리스트의 pop()을 스택의 pop()으로 대체 가능.
* append()와 pop() : O(1)

<br>

<br>

**큐(Queue)**

* First In First Out
* front가 맨 앞의 데이터를 가리키고 rear가 맨 뒤의 데이터를 가리킴.
* 큐를 구현하는 방법
* 1. 리스트
  2. collections 모듈의 deque 클래스(from collections import deque)
  3. queue 모듈의 Queue 클래스(from queue import Queue)

<br>

리스트로 큐를 구현

* 리스트의 append()를 큐의 enqueue()로, pop(0)을 큐의 dequeue()로 사용.
* append()는 O(1)이지만 pop(0)이 O(n)

<br>

collections 모듈의 dequeue 클래스로 큐를 구현

* append()를 큐의 enqueue()로, popleft()를 큐의 dequeue()로 사용.
* popleft() : O(1)
* 내부적으로 연결 리스트를 사용하므로 데이터 조회시 O(n)

<br>

queue 모듈의 Queue 클래스로 큐를 구현

* put()을 큐의 enqueue()로, get()을 큐의 dequeue()로 사용.
* put(), get() : O(1)
* 데이터 조회시 O(n)

<br>

**원형 큐(Circular Queue)**

* 큐의 pop() 연산이 O(n)인 문제(dequeue 연산마다 모든 데이터를 한칸씩 앞으로 이동시켜야함)를 해결한 방식.
* dequeue 연산시 front를 뒤로 한칸만 이동시켜서 해결.
* enqueue 연산시 rear가 맨 뒤에 도착했을때 동적 배열의 맨 앞을 가리키게함.

<br>

<br>

**우선순위 큐(Priority Queue)**

* 우선순위가 가장 높은 요소가 추출되는 자료형.
* 힙을 사용해서 구현
* import heapq   # 최소 힙이 기본 설정
* heapq.heappush(리스트 변수, 값)
* heapq.heappop(리스트 변수)
* heapq.heapify(리스트 변수)   # 기존의 리스트를 힙으로 만듦

<br>

<br>

**데크(Double-ended Queue)**

* 스택과 큐를 일반화한 것으로 front와 rear 모두에서 입출력이 가능.
* from collections import deque
* append()는 rear에 입력하는 것, pop()은 rear를 출력하는 것.
* appendleft()는 front에 입력하는 것, popleft()은 front를 출력하는 것.
* append(), appendleft(), pop(), popleft() : O(1)

<br>

<br>

**해시 테이블(Hash Table)**

* 해시 함수 : 임의 크기 데이터를 고정 크기 값으로 매핑하는데 사용할 수 있는 함수.
* 해싱(Hashing) : 해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것.
* 딕셔너리 자료형은 해시 테이블로 구현됨.

<br>

<br>

**그래프(Graph)**

* 정점(vertex)(노드)의 집합인 V(G)와 엣지(edge)의 집합인 E(G)로 정의됨(G = (V, E)).
* 무방향 그래프(undirected graph)에서 노드의 개수가 n개일때 최대 엣지의 개수는 n * (n - 1) / 2개.
* 방향 그래프(directed graph)에서 노드의 개수가 n개일때 최대 엣지의 개수는 n* (n-1)개.
* 차수(degree) : 노드의 엣지 개수.
* 방향 그래프는 진입 차수(in-degree)와 진출 차수(out-degree)로 구성되는데 이를 합친 것을 차수라 함.
* 부분 그래프(subgraph) : V(G')$\subseteq$(G)이고 E(G')$\subseteq$E(G)이면 부분 그래프.
* 신장 부분 그래프(spanning subgraph) : V'=V이고 E(G')$\subseteq$E(G)이면 신장 부분 그래프.

<br>

그래프를 표현하는 방법에는 인접 리스트(adjacency list)와 인접 행렬(adjacency matrix)이 있음.

![graph](../image/graph.png)

1. 인접 리스트 : 연결 리스트들을 배열로 관리하는 방식으로 특정 노드와 인접한 노드를 탐색하는데 O(d(v)), 특정 노드들이 연결되었는지 탐색하는데 O(d(v))
2. 인접 행렬 : 2차원 배열로 표현하며 두 노드가 연결되었다면 1, 연결되지않으면 0으로 표현. 노드 개수가 n개일때 특정 노드와 인접한 노드를 탐색하는데 O(n), 특정 노드들이 연결되었는지 탐색하는데 O(1)


<br>

그래프를 순회하는 방법에는 너비 우선 탐색(BFS, Breadth First Search)과 깊이 우선 탐색(DFS, Depth First Search)이 있음.

* 너비 우선 탐색(BFS)
* 1. 큐를 이용해서 구현.
  2. 시작 노드에서 가까운 노드를 먼저 방문하고 방문한 노드와 인접한 노드를 방문하고 멀리 떨어진 노드를 나중에 방문하는 방법.
  3. 방문할 노드를 enqueue()하고 방문했다면 방문 여부를 True로 바꾸고 dequeue(). 
  4. 두 노드 사이의 최단 경로나 임의의 경로를 찾을때 사용.
  5. 특정 노드의 방문 여부를 확인해야함.
* 깊이 우선 탐색(DFS)
  1. 재귀 구조로 구현하거나 스택을 이용해 구현
  2. 시작 노드에서 시작해 한 방향으로 갈 수 있는한 최대로 방문하고 방문할 곳이 없다면 되돌아와 다른 방향을 방문하는 방법. 
  3. 모든 노드를 방문하고자 할때 사용.
  4. 특정 노드의 방문 여부를 확인해야함.


<br>

**DFS, BFS 구분 기준**

* DFS
* 1. 완전 탐색하는 경우(순열, 조합의 경우)
* BFS
* 1. 최단 거리를 찾는 경우

<br>

<br>

**최단 경로**

* 다익스트라 알고리즘을 사용
* 다익스트라 알고리즘 : 노드 주변의 최단 경로만을 선택하는 그리디 알고리즘으로 주변 노드를 탐색할 때 BFS를 사용
* 가중치가 음수인 경우에는 사용할 수 없어 벨만-포드 알고리즘을 사용
* 최장 경로를 구하는 문제에서는 사용 못 함 

<br>

<br>

**트리(Tree)**

* 사이클이 없는 그래프.
* 엣지 개수 = 노드 개수 - 1
* 깊이 = 루트 노드에서 특정 노드에 도달하기위해 거쳐야하는 엣지 개수.
* 높이 = 단말 노드에서 특정 노드에 도달하기위해 거쳐야하는 엣지 개수.

<br>

**이진 트리(Binary Tree)**

* 자식 노드의 개수가 최대 2개인 트리.
* 루트 노드가 레벨 0일때 레벨 n에서 최대 노드의 개수는 $2^n$
* 높이가 h일때 최대 노드의 개수는 $2^{h+1} - 1$
* 높이가 h일때 최소 노드의 개수는 h + 1

<br>

**포화 이진 트리(Full Binary Tree)**

* 마지막 레벨까지 모든 노드가 차있는 트리.
* 높이가 h일때 노드의 개수는 $2^{h+1} - 1$

<br>

**완전 이진 트리(Complete Binary Tree)**

* 마지막 레벨전까지 모든 노드가 차있으며 마지막 레벨에서 왼쪽부터 삽입되는 트리.


<br>

**트리 순회(Tree Traversal)**

* 전위, 중위, 후위 순회는 DFS의 일종으로 스택을 이용해 구현.
  1. 전위 순회(Preorder Traversal) : 현재 노드 -> 왼쪽 서브 트리 -> 오른쪽 서브 트리
  2. 중위 순회(Inorder Traversal) : 왼쪽 서브 트리 -> 현재 노드 -> 오른쪽 서브 트리
  3. 후위 순회(Postorder Traversal) : 왼쪽 서브 트리 -> 오른쪽 서브 트리 -> 현재 노드
* 레벨 순서 순회는 BFS의 일종으로 큐를 이용해 구현.


<br>

**이진 탐색 트리(BST, Binary Search Tree)**

* 모든 키는 유일.
* 특정 노드의 키는 왼쪽 서브 트리의 키들보다 큼.
* 특정 노드의 키는 오른쪽 서브 트리의 키들보다 작음.
* 높이가 h일때 삽입, 삭제, 탐색 : O(h)
* 노드 개수가 N개일때 삽입, 삭제, 탐색 : O(logN))
* 편향된 이진 탐색 트리일 경우 삽입, 삭제, 탐색 : O(N)


**균형 이진 트리(Balanced Binary Tree)**

* AVL 트리, 레드 블랙 트리, B 트리

<br>

**레드 블랙 트리(Red-Black Tree)**

* 외부 노드(external node) : 기존의 리프 노드들에 자식으로 추가되는 노드.
* 모든 노드는 빨간색 아니면 검은색.
* 루트 노드와 외부 노드는 검은색.
* 빨간색 노드가 연속으로 나올 수 없음(빨간색 노드의 자식은 검은색).
* 루트 노드에서 외부 노드까지가는 모든 경로에서 검은색 노드의 개수는 같음.

<br>

<br>

**힙(Heap)**

* 트리 기반 자료구조
* 최소 힙 : 부모가 항상 자식보다 작기때문에 루트가 항상 최소값을 가짐